import geo.Workplane
import standards.thread.Length
import standards.thread.ThreadSize

rule geometry.GeometryUtil

op getLength(length : Length) : Unit[mm] {
	return Double.parseDouble(length.toString.replace("_", ".").substring(1)) * 1[mm]
}

op getDia(thread:ThreadSize) : Unit[mm] {
	return Double.parseDouble(thread.toString.replace("_", ".").substring(1)) * 1[mm]
}

/*
 * Create standard internal hexagonal driving feature
 */
op createHexagonRecess(width:Double, depth:Double, chamfer :boolean) : Workplane {
	val coneOffset = 2 * depth + width / 3 - 0.08 * width * sqrt(3) / 3
	val hexPrism = workplane.sketch[polygon(6, width/ sqrt(3) * 2)].extrude(depth, [secondLimit = depth])
	val cone = workplane(plane[origin = #[0,0,depth] normal = #[0, 0, -1]]).cone(
		(3 * depth + width) / sqrt(3) + depth * sqrt(3), width * 0.08, coneOffset, [centered = #{true, true, false}])
		.translate(#[0, 0, depth])
	var recess = hexPrism.intersect(cone)
	if (chamfer) {
		val r_3 = width * 0.49
		val r_2 = 1.005 * width / sqrt(3)
		val r_1 = depth + r_2 // # math.tan(math.radians(45.)) = 1.
		val h_1 = r_2 - r_3
		val cone2 = workplane(plane[origin = #[0,0,depth], normal = #[0, 0, -1]]).
			cone(r_1, r_3, depth + h_1, [centered = #{true, true, false}]).translate(#[0,0,depth])
		recess = recess.union(cone2)
	}
	return recess
}

op createHexalobularRecess(driveSize:String, depth:Double, chamfer :boolean) : Workplane {
	val sizeMap = map
		// "DriveSize","A","B","Re"
		sizeMap.put("T6", #{1.75, 1.205, 0.14})
		sizeMap.put("T8", #{2.4, 1.67, 0.2})
		sizeMap.put("T10", #{2.8, 1.98, 0.24})
		sizeMap.put("T15", #{3.35, 2.35, 0.28})
		sizeMap.put("T20", #{3.95, 2.75, 0.32})
		sizeMap.put("T25", #{4.5, 3.16, 0.39})
		sizeMap.put("T30", #{5.6, 3.95, 0.46})
		sizeMap.put("T40", #{6.75, 4.76, 0.56})
		sizeMap.put("T45", #{7.93, 5.55, 0.59})
		sizeMap.put("T50", #{8.95, 6.36, 0.78})
		sizeMap.put("T55", #{11.35, 7.92, 0.77})
		sizeMap.put("T60", #{13.45, 9.48, 1.07})
		sizeMap.put("T70", #{15.7, 11.08, 1.2})
		sizeMap.put("T80", #{17.75, 12.64, 1.53})
		sizeMap.put("T90", #{20.2, 14.22, 1.54})
		sizeMap.put("T100", #{22.4, 15.81, 1.73})
		
	val params = sizeMap.get(driveSize)
	val A = params.get(0)
	val B = params.get(1)
	val Re = params.get(2)
	val width = sqrt(3) * A / 2

	val Ri = -((B + sqrt(3) * (2.0 * Re - A)) * B + (A - 4.0 * Re) * A) / (4.0 * B - 2.0 * sqrt(3) * A + (4.0 * sqrt(
		3) - 8.0) * Re)
	val beta = Math.acos(A / (4 * Ri + 4 * Re) - (2 * Re) / (4 * Ri + 4 * Re)) - pi / 6
	val Re_x = A / 2.0 - Re + Re * Math.sin(beta)
	val Re_y = Re * Math.cos(beta)
	val Ri_y = B / 4.0
	val Ri_x = sqrt(3) * B / 4.0

	val sketchDef = workplane.sketch [moveTo(Re_x, -Re_y).threePointArc(#[A / 2, 0.0], #[Re_x, Re_y])
		.threePointArc(#[Ri_x, Ri_y], #[0.5*Re_x + sqrt(3)/2 * Re_y, sqrt(3)/2 * Re_x - 0.5 * Re_y])
	]
	var sketch = workplane
	for (var i = 0; i < 6; i++) {
		val angleStep = 60 * i
		sketch = sketch.add(sketchDef.rotate[angle = angleStep])
	}
	val prism = workplane.addSketch(sketch).extrude(depth, [secondLimit = depth])

	val coneOffset = 2 * depth + width / 3 - 0.08 * width * sqrt(3) / 3
	val cone = workplane(plane[origin = #[0, 0, depth] normal = #[0, 0, -1]]).cone(
		(3 * depth + width) / sqrt(3) + depth * sqrt(3), width * 0.08, coneOffset, [centered = #{true, true, false}]).
		translate(#[0, 0, depth])
	var recess = prism.intersect(cone)
	
	if (chamfer) {
		val r_1 = 0.505 * A + depth / Math.tan(Math.toRadians(18))
		val r_2 = 0.49 * B
		val h_1 = depth + (0.505 * A - 0.49 * B) * Math.tan(Math.toRadians(18))
		val cone2 = workplane(plane[origin = #[0,0,0], normal = #[0,0,-1]])
    	.cone(r_1, r_2, h_1, [centered = #{true, true, false}]).translate(#[0,0,depth*2])
		recess = recess.union(cone2)
	}
}

op createSlotRecess(width : Double, depth: Double, headDiameter : Double) : Workplane {
	val slotGeo = workplane.box(headDiameter+10.0,width, depth*2)
	return slotGeo
}

op createCrossRecess(crossType : String, m : Double) : Workplane {
	val sizeMap = map
//	"Size","b","e_min","g","f_mean","r","t1","alpha","beta" })
	sizeMap.put("0", #{0.61, 0.26, 0.81, 0.34, 0.3, 0.22, 138.0, 7.0})
	sizeMap.put("1", #{0.97, 0.41, 1.27, 0.54, 0.5, 0.34, 138.0, 7.0})
	sizeMap.put("2", #{1.47, 0.79, 2.29, 0.7, 0.6, 0.61, 140.0, 5.75})
	sizeMap.put("3", #{2.41, 1.98, 3.81, 0.83, 0.8, 1.01, 146.0, 5.75})
	sizeMap.put("4", #{3.48, 2.39, 5.08, 1.23, 1.0, 1.35, 153.0, 7.0})

	val params = sizeMap.get(crossType)
	val b = params.get(0)
	val e_mean = params.get(1)
	val g = params.get(2)
	val f_mean = params.get(3)
	val r = params.get(4)
	val t1 = params.get(5)
	val alpha = params.get(6)
	val beta = params.get(7)

	val rad265 = Math.toRadians(26.5)
	val rad28 = Math.toRadians(28.0)
	val tg = (m - g) / 2.0 / tan(rad265) // depth at radius of g
	val t_tot = tg + g / 2.0 * tan(rad28) // total depth
	val hm = m / 4.0
	val hmc = m / 2.0
	val rmax = m / 2.0 + hm * tan(rad265)

	var crossGeo = workplane("XZ").sketch [
     	lineTo(0, hm).lineTo(rmax, hm).lineTo(g/2, -tg).lineTo(0, -t_tot).close
     ].revolve[axis = Z]

	val rad_alpha = Math.toRadians(alpha / 2.0)
	val rad92 = Math.toRadians(92.0 / 2.0)
	val rad_beta = Math.toRadians(beta)

	val rad_alpha_p = atan(tan(rad_alpha) / cos(rad_beta))
	val rad92_p = atan(tan(rad92) / cos(rad_beta))

	val tb = tg + (g - b) / 2.0 * tan(rad28) // depth at dimension b
//       radius of b-corner at hm
	val rbtop = b / 2.0 + (hmc + tb) * tan(rad_beta)
	// radius of b-corner at t_tot
	val rbtot = b / 2.0 - (t_tot - tb) * tan(rad_beta)

	// delta between corner b and corner e in x direction
	val dre = e_mean / 2.0 / tan(rad_alpha_p)

	val dx = m / 2.0 * cos(rad92_p)
	val dy = m / 2.0 * sin(rad92_p)

	val PntC0 = #[rbtop, 0.0, hmc]
	val PntC1 = #[rbtot, 0.0, -t_tot]

	var crossEdgeGeo = workplane(plane[origin = #[0, 0, -t_tot]]).sketch [
    	moveTo(rbtot + dre + 2.0 * dx, e_mean + 2.0 * dy)
    	.lineTo(rbtot + dre + 2.0 * dx, -e_mean - 2.0 * dy)
    	.lineTo(rbtot + dre, -e_mean / 2.0)
    	.lineTo(rbtot, 0.0)
    	.lineTo(rbtot + dre, e_mean / 2.0)
    	.close
    ].extrude(1, [direction = PntC0.subtract(PntC1)])

	for (var i = 0; i <= 4; i++) {
		val rotCount = i
		crossGeo = crossGeo.cut(crossEdgeGeo.rotate[angle = rotCount * 90[deg] axis = #[0, 0, 1]])
	}
     

	return crossGeo
}