import standards.hexheadboltwithflange.EN1662
import standards.hexheadboltwithflange.EN1665
import standards.hexheadboltwithflange.ISO15071
import standards.hexheadboltwithflange.ISO4162
import topology.Bolt
import topology.BoltHead
import topology.BoltShaft
import standards.thread.ThreadSize
import topology.Standard
import standards.hexheadboltwithflange.HexHeadWithFlangeStandard
import standards.hexheadboltwithflange.HexHeadWithFlangeStandardType

/**
 * @match
 * @do
 * @precondition
 */
rule geometry.createHexHeadBoltWithFlange(d:ThreadSize = ThreadSize.M6, length:Unit[mm] = 20[mm], standard:HexHeadWithFlangeStandardType = HexHeadWithFlangeStandardType.ISO15071) // make enum
// Translated from FsFunctions/FSmakeHexHeadWithFlange.py
// Supported: ISO 4162, ISO 15071, ISO 15072, EN 1662, EN 1665, ASMEB18.2.1.8
// Builds a flanged hex head by revolving the profile generated below and
// intersecting it with a hex prism, then fuses it with the shaft+flange of the bolt.
do {
	G+[
		(bolt:Bolt)-[:head]->(boltHead:BoltHead)
		(bolt)-[:shaft]->(boltShaft:BoltShaft)
		(bolt)-[:standard]->(hexHeadWithFlangeStandard:HexHeadWithFlangeStandard)
	]

	var parameters = list
	var partID = standard.toString
	switch (standard) {
		case EN1662: {
			hexHeadWithFlangeStandard.changeClassifier(EN1662)
			hexHeadWithFlangeStandard.setParameters
		}
		case EN1665: {
			hexHeadWithFlangeStandard.changeClassifier(EN1665)
			hexHeadWithFlangeStandard.setParameters
		}
		case ISO4162: {
			hexHeadWithFlangeStandard.changeClassifier(ISO4162)
			hexHeadWithFlangeStandard.setParameters
		}
		case ISO15071: {
			hexHeadWithFlangeStandard.changeClassifier(ISO15071)
			hexHeadWithFlangeStandard.setParameters
		}
		default:
			throw new IllegalArgumentException("standard not implemented.")
	}

	val sqrt2 = sqrt(2.0)
	val sqrt3 = sqrt(3.0)
	val beta = Math.toRadians(25.0)
	val tanBeta = tan(beta)

	val dia = hexHeadWithFlangeStandard.dia
	val P = hexHeadWithFlangeStandard.P
	val b0 = hexHeadWithFlangeStandard.b0
	val b1 = hexHeadWithFlangeStandard.b1
	val b2 = hexHeadWithFlangeStandard.b2
	val b3 = hexHeadWithFlangeStandard.b3
	val c = hexHeadWithFlangeStandard.c
	val dc = hexHeadWithFlangeStandard.dc
	val kw = hexHeadWithFlangeStandard.kw
	val r1 = hexHeadWithFlangeStandard.r1
	val s = hexHeadWithFlangeStandard.s

	var threadLimit = b0
	if (length < b0) {
		threadLimit = length - r1
	} else if (standard != "ASMEB18.2.1.8") {
		threadLimit = if(length <= 125.0) b1 else if(length <= 200.0) b2 else b3
	}

	val chamfer = s * (2.0 / sqrt3 - 1.0) * sin(Math.toRadians(25.0))
	val arc1X = dc / 2.0 - c / 2.0 + (c / 2.0) * sin(beta)
	val arc1Z = c / 2.0 + (c / 2.0) * cos(beta)
	val kmean = arc1Z + (arc1X - s / sqrt3) * tanBeta + kw * 1.1 + chamfer
	val flangeTop = tanBeta * ((dc - c) / 2.0 - s * 0.4 + (c / 2.0) / tan(beta / 2.0))

	val headGeoUncut = workplane("XZ").sketch [
        moveTo(0, 0)
        .lineTo(0.0, kmean * 0.9)
        .lineTo(s * 0.4 - r1 / 2.0, kmean * 0.9)
		.tangentArc(r1/2, 90)
        .lineTo(s * 0.4, kmean - r1)
        .tangentArc(r1, -90)
        .lineTo(s / 2.0, kmean)
        .lineTo(s / 2.0 + (kmean - 0.1) * sqrt3, 1.0)
        .close
    ].revolve[axis = Z]
	val hexPrism = workplane("XY").sketch [
        moveTo(0.0, 0.0).polygon(6, s / sqrt3 * 2.0)
    ].extrude(kmean)
	val topHeadGeo = headGeoUncut.intersect(hexPrism)

	val headFlangeGeo = workplane("XZ").sketch [
        moveTo(0, 0)
        .lineTo((dc - c) / 2, 0.0)
        .tangentArc(c / 2, 180 - Math.toDegrees(beta))
        .lineTo(s * 0.4, flangeTop)
    	.lineTo(0.0, flangeTop)
    	.close
        ].revolve[axis = Z]
	val headGeo = headFlangeGeo.union(topHeadGeo)

	val unthreadedRunout = length - threadLimit

	val shaftGeo = workplane("XZ").sketch [
        moveTo(fix(0.0), fix(0.0))
        .lineTo(fix(0.0), fix(-length))
        .lineTo(fix(dia * 0.4), fix(-length))
        .lineTo(fix(dia / 2.0), fix(-length + dia / 10.0))
        .lineTo(fix(dia / 2.0), fix(-unthreadedRunout))
        .tangentArc(r1, -90)
        .close
    ].revolve[axis = Z]
	boltHead.part = part(partDefinition(partID + "_" + d + "_head", headGeo))
	boltShaft.part = part(partDefinition(partID + "_" + length.doubleValue + "_shaft", shaftGeo))

	val boltGeo = headGeo.union(shaftGeo)
	show
//    val threadLength = min(threadLimit, length - r1)
//    val threadCutter = geometry.createBlindThreadCutter(dia, P, threadLength)
//        .translate(#[0.0, 0.0, - (length - threadLength)])
//    val finalBolt = boltGeo.cut(threadCutter)
	bolt.part = part(partDefinition(partID + "_" + d + "_" + length.doubleValue, boltGeo))
}

